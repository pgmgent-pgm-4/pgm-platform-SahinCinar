{"version":3,"file":"index.modern.js","sources":["../node_modules/extract-files/public/ReactNativeFile.js","../node_modules/extract-files/public/isExtractableFile.js","../node_modules/extract-files/public/extractFiles.js","../src/GraphQLRequestError.ts","../src/util/assert.ts","../src/util/isFileUpload.ts","../src/AwesomeGraphQLClient.ts","../src/util/formatGetRequestUrl.ts","../src/util/isResponseJSON.ts","../src/util/gql.ts"],"sourcesContent":["'use strict';\n\nmodule.exports = function ReactNativeFile(_ref) {\n  var uri = _ref.uri,\n    name = _ref.name,\n    type = _ref.type;\n  this.uri = uri;\n  this.name = name;\n  this.type = type;\n};\n","'use strict';\n\nvar ReactNativeFile = require('./ReactNativeFile');\n\nmodule.exports = function isExtractableFile(value) {\n  return (\n    (typeof File !== 'undefined' && value instanceof File) ||\n    (typeof Blob !== 'undefined' && value instanceof Blob) ||\n    value instanceof ReactNativeFile\n  );\n};\n","'use strict';\n\nvar defaultIsExtractableFile = require('./isExtractableFile');\n\nmodule.exports = function extractFiles(value, path, isExtractableFile) {\n  if (path === void 0) {\n    path = '';\n  }\n\n  if (isExtractableFile === void 0) {\n    isExtractableFile = defaultIsExtractableFile;\n  }\n\n  var clone;\n  var files = new Map();\n\n  function addFile(paths, file) {\n    var storedPaths = files.get(file);\n    if (storedPaths) storedPaths.push.apply(storedPaths, paths);\n    else files.set(file, paths);\n  }\n\n  if (isExtractableFile(value)) {\n    clone = null;\n    addFile([path], value);\n  } else {\n    var prefix = path ? path + '.' : '';\n    if (typeof FileList !== 'undefined' && value instanceof FileList)\n      clone = Array.prototype.map.call(value, function (file, i) {\n        addFile(['' + prefix + i], file);\n        return null;\n      });\n    else if (Array.isArray(value))\n      clone = value.map(function (child, i) {\n        var result = extractFiles(child, '' + prefix + i, isExtractableFile);\n        result.files.forEach(addFile);\n        return result.clone;\n      });\n    else if (value && value.constructor === Object) {\n      clone = {};\n\n      for (var i in value) {\n        var result = extractFiles(value[i], '' + prefix + i, isExtractableFile);\n        result.files.forEach(addFile);\n        clone[i] = result.clone;\n      }\n    } else clone = value;\n  }\n\n  return {\n    clone: clone,\n    files: files,\n  };\n};\n","import { RequestResult } from './util/types'\n\nexport class GraphQLRequestError<\n\tTResponse extends RequestResult = Response,\n> extends Error {\n\tquery: string\n\tvariables?: Record<string, unknown>\n\tresponse: TResponse\n\n\tconstructor({\n\t\tquery,\n\t\tvariables,\n\t\tresponse,\n\t\tmessage,\n\t}: {\n\t\tquery: string\n\t\tvariables?: Record<string, unknown>\n\t\tresponse: TResponse\n\t\tmessage: string\n\t}) {\n\t\tsuper(`GraphQL Request Error: ${message}`)\n\n\t\tthis.query = query\n\t\tthis.variables = variables\n\t\tthis.response = response\n\t}\n}\n","export function assert(condition: any, msg: string): asserts condition {\n\tif (!condition) {\n\t\tthrow new Error(msg)\n\t}\n}\n","export type StreamLike = { pipe: (...args: unknown[]) => unknown }\n\n/** Uploadable file */\nexport type FileUpload = File | Blob | Buffer | StreamLike | Promise<unknown>\n\n/**\n * Duck-typing if value is a stream\n * https://github.com/sindresorhus/is-stream/blob/3750505b0727f6df54324784fe369365ef78841e/index.js#L3\n *\n * @param value incoming value\n */\nconst isStreamLike = (value: any): value is StreamLike =>\n\ttypeof value === 'object' && value !== null && typeof value.pipe === 'function'\n\n/**\n * Duck-typing if value is a promise\n *\n * @param value incoming value\n */\nconst isPromiseLike = (value: any): value is Promise<unknown> =>\n\ttypeof value === 'object' && value !== null && typeof value.then === 'function'\n\n/**\n * Returns true if value is a file.\n * Supports File, Blob, Buffer and stream-like instances\n *\n * @param value incoming value\n */\nexport const isFileUpload = (value: unknown): value is FileUpload =>\n\t(typeof File !== 'undefined' && value instanceof File) ||\n\t(typeof Blob !== 'undefined' && value instanceof Blob) ||\n\t(typeof Buffer !== 'undefined' && value instanceof Buffer) ||\n\tisStreamLike(value) ||\n\tisPromiseLike(value)\n","import { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport { extractFiles } from 'extract-files'\n\nimport { GraphQLRequestError } from './GraphQLRequestError'\nimport { assert } from './util/assert'\nimport { formatGetRequestUrl } from './util/formatGetRequestUrl'\nimport { isFileUpload, FileUpload } from './util/isFileUpload'\nimport { isResponseJSON } from './util/isResponseJSON'\nimport { FetchOptions, RequestResult } from './util/types'\n\nexport class AwesomeGraphQLClient<\n\tTQuery = string,\n\tTFetchOptions extends FetchOptions = Omit<RequestInit, 'headers'> &\n\t\tPick<FetchOptions, 'headers'>,\n\tTRequestResult extends RequestResult = Response,\n\tTFileUpload = FileUpload,\n> {\n\tprivate endpoint: string\n\tprivate fetch: (url: string, options?: TFetchOptions) => Promise<TRequestResult>\n\tprivate fetchOptions?: TFetchOptions\n\tprivate formatQuery?: (query: TQuery) => string\n\tprivate FormData: any\n\tprivate onError?: (error: GraphQLRequestError | Error) => void\n\tprivate isFileUpload: (value: unknown) => value is TFileUpload\n\n\tconstructor(config: {\n\t\t/** GraphQL endpoint */\n\t\tendpoint: string\n\t\t/** Fetch polyfill if necessary */\n\t\tfetch?: (url: string, options?: any) => Promise<TRequestResult>\n\t\t/** FormData polyfill if necessary */\n\t\tFormData?: any\n\t\t/** Overrides for fetch options */\n\t\tfetchOptions?: TFetchOptions\n\t\t/** Custom query formatter */\n\t\tformatQuery?: (query: TQuery) => string\n\t\t/** Callback will be called on error  */\n\t\tonError?: (error: GraphQLRequestError | Error) => void\n\t\t/** Custom predicate function for checking if value is a file */\n\t\tisFileUpload?: (value: unknown) => value is TFileUpload\n\t}) {\n\t\tassert(config.endpoint, 'endpoint is required')\n\n\t\tassert(\n\t\t\tconfig.fetch || typeof fetch !== 'undefined',\n\t\t\t'Fetch must be polyfilled or passed in new AwesomeGraphQLClient({ fetch })',\n\t\t)\n\n\t\tassert(\n\t\t\t!config.formatQuery || typeof config.formatQuery === 'function',\n\t\t\t'Invalid config value: `formatQuery` must be a function',\n\t\t)\n\n\t\tassert(\n\t\t\t!config.onError || typeof config.onError === 'function',\n\t\t\t'Invalid config value: `onError` must be a function',\n\t\t)\n\n\t\tassert(\n\t\t\t!config.isFileUpload || typeof config.isFileUpload === 'function',\n\t\t\t'Invalid config value: `isFileUpload` should be a function',\n\t\t)\n\n\t\tthis.endpoint = config.endpoint\n\t\tthis.fetch = config.fetch || (fetch.bind(null) as any)\n\t\tthis.fetchOptions = config.fetchOptions\n\n\t\tthis.FormData =\n\t\t\tconfig.FormData || (typeof FormData !== 'undefined' ? FormData : undefined)\n\n\t\tthis.formatQuery = config.formatQuery\n\t\tthis.onError = config.onError\n\t\tthis.isFileUpload = config.isFileUpload || (isFileUpload as any)\n\t}\n\n\tprivate createRequestBody(\n\t\tquery: string,\n\t\tvariables?: Record<string, unknown>,\n\t): string | FormData {\n\t\tconst { clone, files } = extractFiles({ query, variables }, '', this.isFileUpload)\n\t\tconst operationJSON = JSON.stringify(clone)\n\n\t\tif (!files.size) {\n\t\t\treturn operationJSON\n\t\t}\n\n\t\tassert(\n\t\t\tthis.FormData,\n\t\t\t'FormData must be polyfilled or passed in new AwesomeGraphQLClient({ FormData })',\n\t\t)\n\n\t\tconst form = new this.FormData()\n\n\t\tform.append('operations', operationJSON)\n\n\t\tconst map: Record<string, string[]> = {}\n\t\tlet i = 0\n\t\tfiles.forEach(paths => {\n\t\t\tmap[++i] = paths\n\t\t})\n\t\tform.append('map', JSON.stringify(map))\n\n\t\ti = 0\n\t\tfiles.forEach((paths, file) => {\n\t\t\tform.append(`${++i}`, file)\n\t\t})\n\n\t\treturn form\n\t}\n\n\t/**\n\t * Returns current GraphQL endpoint\n\t */\n\tgetEndpoint(): string {\n\t\treturn this.endpoint\n\t}\n\n\t/**\n\t * Sets new overrides for fetch options\n\t *\n\t * @param fetchOptions new overrides for fetch options\n\t */\n\tsetFetchOptions(fetchOptions: TFetchOptions): void {\n\t\tthis.fetchOptions = fetchOptions\n\t}\n\n\t/**\n\t * Returns current overrides for fetch options\n\t */\n\tgetFetchOptions(): TFetchOptions | undefined {\n\t\treturn this.fetchOptions\n\t}\n\n\t/**\n\t * Sends GraphQL Request and returns object with 'ok: true', 'data' and 'response' fields\n\t * or with 'ok: false' and 'error' fields.\n\t * Notice: this function never throws\n\t *\n\t * @example\n\t * const result = await requestSafe(...)\n\t * if (!result.ok) {\n\t *   throw result.error\n\t * }\n\t * console.log(result.data)\n\t *\n\t * @param query query\n\t * @param variables variables\n\t * @param fetchOptions overrides for fetch options\n\t */\n\tasync requestSafe<\n\t\t// Should be \"any\" and not \"unknown\" to be compatible with interfaces\n\t\t// https://github.com/microsoft/TypeScript/issues/15300#issuecomment-702872440\n\t\tTData extends Record<string, any>,\n\t\tTVariables extends Record<string, any> = Record<string, never>,\n\t>(\n\t\tquery: TQuery extends TypedDocumentNode\n\t\t\t? TypedDocumentNode<TData, TVariables>\n\t\t\t: TQuery,\n\t\tvariables?: TVariables,\n\t\tfetchOptions?: TFetchOptions,\n\t): Promise<\n\t\t| { ok: true; data: TData; response: TRequestResult }\n\t\t| { ok: false; error: GraphQLRequestError<TRequestResult> | Error }\n\t> {\n\t\ttry {\n\t\t\tconst queryAsString = this.formatQuery ? this.formatQuery(query as TQuery) : query\n\n\t\t\tassert(\n\t\t\t\ttypeof queryAsString === 'string',\n\t\t\t\t`Query should be a string, not ${typeof queryAsString}. Otherwise provide formatQuery option`,\n\t\t\t)\n\n\t\t\tconst options = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\t...this.fetchOptions,\n\t\t\t\t...fetchOptions,\n\t\t\t\theaders: {\n\t\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t\t...fetchOptions?.headers,\n\t\t\t\t},\n\t\t\t} as TFetchOptions\n\n\t\t\tlet response: TRequestResult | Response\n\n\t\t\tif (options.method?.toUpperCase() === 'GET') {\n\t\t\t\tconst url = formatGetRequestUrl({\n\t\t\t\t\tendpoint: this.endpoint,\n\t\t\t\t\tquery: queryAsString,\n\t\t\t\t\tvariables,\n\t\t\t\t})\n\t\t\t\tresponse = await this.fetch(url, options)\n\t\t\t} else {\n\t\t\t\tconst body = this.createRequestBody(queryAsString, variables)\n\n\t\t\t\tresponse = await this.fetch(this.endpoint, {\n\t\t\t\t\t...options,\n\t\t\t\t\tbody,\n\t\t\t\t\theaders:\n\t\t\t\t\t\ttypeof body === 'string'\n\t\t\t\t\t\t\t? { ...options.headers, 'Content-Type': 'application/json' }\n\t\t\t\t\t\t\t: options.headers,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (!response.ok) {\n\t\t\t\tif (isResponseJSON(response as any)) {\n\t\t\t\t\tconst { errors } = await response.json()\n\n\t\t\t\t\tif (errors?.[0]?.message) {\n\t\t\t\t\t\tthrow new GraphQLRequestError({\n\t\t\t\t\t\t\tquery: queryAsString,\n\t\t\t\t\t\t\tvariables,\n\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\tmessage: errors[0].message,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new GraphQLRequestError({\n\t\t\t\t\tquery: queryAsString,\n\t\t\t\t\tvariables,\n\t\t\t\t\tresponse,\n\t\t\t\t\tmessage: `Http Status ${response.status}`,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst { data, errors } = await response.json()\n\n\t\t\tif (errors?.[0]) {\n\t\t\t\tthrow new GraphQLRequestError({\n\t\t\t\t\tquery: queryAsString,\n\t\t\t\t\tvariables,\n\t\t\t\t\tresponse,\n\t\t\t\t\tmessage: errors[0].message,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn { ok: true, data, response }\n\t\t} catch (err) {\n\t\t\tconst error = err instanceof Error ? err : new Error(String(err))\n\n\t\t\tif (this.onError) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.onError(error)\n\t\t\t\t} catch (err) {\n\t\t\t\t\treturn { ok: false, error }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { ok: false, error }\n\t\t}\n\t}\n\n\t/**\n\t * Makes GraphQL request and returns data or throws an error\n\t *\n\t * @example\n\t * const data = await request(...)\n\t *\n\t * @param query query\n\t * @param variables variables\n\t * @param fetchOptions overrides for fetch options\n\t */\n\tasync request<\n\t\tTData extends Record<string, any>,\n\t\tTVariables extends Record<string, any> = Record<string, never>,\n\t>(\n\t\tquery: TQuery extends TypedDocumentNode\n\t\t\t? TypedDocumentNode<TData, TVariables>\n\t\t\t: TQuery,\n\t\tvariables?: TVariables,\n\t\tfetchOptions?: TFetchOptions,\n\t): Promise<TData> {\n\t\tconst result = await this.requestSafe<TData, TVariables>(\n\t\t\tquery,\n\t\t\tvariables,\n\t\t\tfetchOptions,\n\t\t)\n\n\t\tif (!result.ok) {\n\t\t\tthrow result.error\n\t\t}\n\n\t\treturn result.data\n\t}\n}\n","/**\n * Returns URL for GraphQL GET Requests:\n * https://graphql.org/learn/serving-over-http/#get-request\n */\nexport function formatGetRequestUrl({\n\tendpoint,\n\tquery,\n\tvariables,\n}: {\n\tendpoint: string\n\tquery: string\n\tvariables?: Record<string, unknown>\n}): string {\n\tconst searchParams = new URLSearchParams()\n\tsearchParams.set('query', query)\n\n\tif (variables && Object.keys(variables).length > 0) {\n\t\tsearchParams.set('variables', JSON.stringify(variables))\n\t}\n\n\treturn `${endpoint}?${searchParams.toString()}`\n}\n","import { RequestResult } from './types'\n\nexport const isResponseJSON = (response: {\n\theaders: RequestResult['headers']\n}): boolean => (response.headers.get('Content-Type') || '').includes('application/json')\n","/**\n * Fake `graphql-tag`.\n * Recommended if you're using `graphql-tag` only for syntax highlighting\n * and static analysis such as linting and types generation.\n * It has less computational cost and makes overall smaller bundles. See:\n * https://github.com/lynxtaa/awesome-graphql-client#approach-2-use-fake-graphql-tag\n */\nexport const gql = (strings: TemplateStringsArray, ...values: any[]): string =>\n\tstrings\n\t\t.reduce((prev, curr, i) => prev + curr + (i in values ? values[i] : ''), '')\n\t\t.trim()\n"],"names":["_ref","name","type","this","uri","value","File","Blob","ReactNativeFile","extractFiles","path","isExtractableFile","clone","defaultIsExtractableFile","files","Map","addFile","paths","file","storedPaths","get","push","apply","set","prefix","FileList","Array","prototype","map","call","i","isArray","child","result","forEach","constructor","Object","GraphQLRequestError","Error","query","variables","response","message","super","assert","condition","msg","isFileUpload","Buffer","pipe","isStreamLike","then","isPromiseLike","AwesomeGraphQLClient","config","endpoint","fetch","fetchOptions","formatQuery","FormData","onError","bind","undefined","createRequestBody","operationJSON","JSON","stringify","size","form","append","getEndpoint","setFetchOptions","getFetchOptions","async","queryAsString","options","method","headers","_this$fetchOptions","toUpperCase","url","searchParams","URLSearchParams","keys","length","toString","formatGetRequestUrl","body","ok","includes","isResponseJSON","errors","json","_errors$","status","data","err","error","String","requestSafe","gql","strings","values","reduce","prev","curr","trim"],"mappings":"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"}